#!/usr/bin/env bash
set -euo pipefail

# Host vs container switch (mirror user.sh/add_pgs.sh behavior)
if [ -z "${INSIDE_DOCKER:-}" ]; then
  ##############################################################################
  ### MODE 1: HOST (WRAPPER)                                                 ###
  ##############################################################################

  # Locate project root (repo root = two levels up from this script)
  THIS_SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &> /dev/null && pwd)
  PROJECT_ROOT=$(cd -- "${THIS_SCRIPT_DIR}/../../" &> /dev/null && pwd)

  DOCKER_IMAGE="${DOCKER_IMAGE:-pgspilot}"

  # Detect host arch and default to amd64 emulation on arm hosts (Apple Silicon)
  DOCKER_PLATFORM="${DOCKER_PLATFORM:-}"
  if [[ -z "$DOCKER_PLATFORM" ]]; then
    host_arch="$(uname -m || true)"
    case "$host_arch" in
      arm64|aarch64)
        DOCKER_PLATFORM="linux/amd64"
        ;;
    esac
  fi

  # Require exactly one input file on host and mount its directory
  if [[ $# -lt 1 ]]; then
    echo "Usage: $0 </path/to/23andme_raw.txt[.gz]>" >&2
    exit 1
  fi
  HOST_INFILE="$1"
  if [[ ! -f "$HOST_INFILE" ]]; then
    echo "Error: Input file not found: $HOST_INFILE" >&2
    exit 1
  fi
  ABS_INPUT_DIR=$(cd -- "$(dirname -- "$HOST_INFILE")" &> /dev/null && pwd)
  INPUT_BASENAME=$(basename -- "$HOST_INFILE")

  # Re-invoke this script inside the container, forwarding all args
  docker run --rm \
    ${DOCKER_PLATFORM:+--platform="$DOCKER_PLATFORM"} \
    -e INSIDE_DOCKER=1 \
    -v "${PROJECT_ROOT}:/app" \
    -v "${ABS_INPUT_DIR}:/app/input_data" \
    "$DOCKER_IMAGE" \
    /app/scripts/pipeline/qc_genome.sh "/app/input_data/$INPUT_BASENAME"

  exit 0
fi

# 23andMe raw file QC + metadata extractor (robust, streaming)
# Usage: qc_23andme.sh path/to/23andme_raw.txt[.gz]
# Output: PROJECT_ROOT/users/STEM/STEM_initial_qc.txt ; exit code 0 on PASS/WARN, 1 on FAIL

# ---------- Tunables (override via env) ----------
EXPECT_V5_MIN="${EXPECT_V5_MIN:-550000}"
EXPECT_V5_MAX="${EXPECT_V5_MAX:-700000}"
EXPECT_V4_MIN="${EXPECT_V4_MIN:-500000}"
EXPECT_V4_MAX="${EXPECT_V4_MAX:-650000}"
EXPECT_V3_MIN="${EXPECT_V3_MIN:-800000}"
EXPECT_V3_MAX="${EXPECT_V3_MAX:-1100000}"

# If variant count does not fit any supported 23andMe window (v3/v4/v5),
# fail the QC by default. Set to 0 to only warn instead.
FAIL_ON_UNKNOWN_VARIANT_COUNT="${FAIL_ON_UNKNOWN_VARIANT_COUNT:-1}"

MAX_BAD_ROWS="${MAX_BAD_ROWS:-0}"          # non-4-field data lines
MAX_MISS_RATE="${MAX_MISS_RATE:-0.05}"     # 5% default is sane
MAX_INVALID_FIELDS="${MAX_INVALID_FIELDS:-0}"  # sum of invalid chr/pos/gt
WARN_OUT_OF_ORDER_FRAC="${WARN_OUT_OF_ORDER_FRAC:-0.01}"  # >1% out-of-order -> warn
WARN_DUP_RSIDS="${WARN_DUP_RSIDS:-1000}"   # warn if > this many duplicate rsids

PROJECT_ROOT="${PROJECT_ROOT:-$(pwd)}"
# -------------------------------------------------

# Require exactly one arg; fail silently if not met (to match your original)
[[ $# -eq 1 ]] || exit 1
INFILE="${1%/}"
[[ -f "$INFILE" ]] || exit 1

# STEM from filename (strip .gz and .txt)
_base="$(basename "$INFILE")"
_base_no_gz="${_base%.gz}"
STEM="${_base_no_gz%.txt}"

# Reader (stream, no temp files)
if [[ "$INFILE" =~ \.gz$ ]]; then
  READER=(gzip -cd -- "$INFILE")
else
  READER=(cat -- "$INFILE")
fi

# Grab up to 200 header lines quickly (comments start with '#')
HEADER="$("${READER[@]}" | sed -n '1,200p' | grep '^#' || true)"

# Metadata
gen_at="$(grep -i '^#.*generated by 23andMe at:' <<<"$HEADER" | sed -E 's/^# *This data file generated by 23andMe at: *//I' | xargs || true)"
gen_build="$(grep -Ei '^#.*(assembly|build|GRCh|hg)[ _-]*([0-9]+)' <<<"$HEADER" | sed -E 's/^# *//;s/\r$//' | head -n1 || true)"

# Column header presence (not required, but nice to report)
col_header="$(grep -E '^# *rsid[[:space:]]+chromosome[[:space:]]+position[[:space:]]+genotype' -i <<<"$HEADER" \
  | sed -E 's/^# *//' | head -n1 || true)"

# Declared version (header rarely says it), fallback to filename
declared_ver="$(
  { grep -Eio 'v[0-9]+' <<<"$HEADER"; grep -Eio 'v[0-9]+' <<<"$_base"; } | head -n1 || true
)"

# Single-pass awk over data lines
stats=()
while IFS= read -r line; do
  stats+=("$line")
done < <(
  "${READER[@]}" | tr -d '\r' | awk -F'\t' '
    BEGIN{
      bad=0; rows=0; miss=0;
      invalid_chr=0; invalid_pos=0; invalid_gt=0;
      dup_rsid=0; out_of_order=0;

      # per-chrom counts
      split("", chr_counts); split("", chr_miss);

      # helper: normalize chromosome tokens
      # Accept: 1..22, X, Y, MT/M, with optional "chr" prefix (case-insensitive)
    }
    function norm_chr(c,    x){
      gsub(/^chr/i,"",c);
      if (c=="M") c="MT";
      if (c ~ /^[0-9]+$/) return c+0;
      if (c=="X") return 23;
      if (c=="Y") return 24;
      if (c=="MT") return 25;
      return -1;
    }
    function chr_label(n){
      return (n<=22)? n : (n==23?"X":(n==24?"Y":"MT"));
    }
    # genotype validity:
    #  - "--" no-call
    #  - length 1: [ACGTID]
    #  - length 2: each in [ACGTID]
    function valid_gt(gt,   L,a,b){
      if (gt=="--") return 1;
      L=length(gt);
      if (L==1) return (gt ~ /^[ACGTID]$/);
      if (L==2) {
        a=substr(gt,1,1); b=substr(gt,2,1);
        return (a ~ /^[ACGTID]$/) && (b ~ /^[ACGTID]$/);
      }
      return 0;
    }
    /^#/ { next }          # skip header/comments
    NF==0 { next }         # skip blank lines
    {
      if (NF!=4) { bad++; next; }

      rs=$1; chr=$2; pos=$3; gt=$4;
      rows++;

      # rsid or i-probe are both fine (track non-rsid count just for info)
      if (rs ~ /^rs[0-9]+$/) { rs_is_rsid=1 } else if (rs ~ /^i[0-9]+$/) { rs_is_rsid=0 } else { rs_is_rsid=0; non_rsid++ }

      cnum=norm_chr(chr);
      if (cnum<0 || cnum>25) invalid_chr++;

      if (pos !~ /^[0-9]+$/ || pos==0) invalid_pos++;

      if (!valid_gt(gt)) invalid_gt++;

      if (gt=="--") { miss++; chr_miss[cnum]++ }

      # per-chrom counts (only if chr valid)
      if (cnum>=1 && cnum<=25) chr_counts[cnum]++;

      # duplicate rsids (count once per additional observation)
      if (seen[rs]++) dup_rsid++;

      # out-of-order by chr/pos (only when both valid)
      if (rows==1) { prevc=cnum; prevp=pos+0; }
      else {
        if (cnum!=-1 && prevc!=-1) {
          if (cnum<prevc || (cnum==prevc && (pos+0)<prevp)) out_of_order++;
        }
        prevc=cnum; prevp=pos+0;
      }
    }
    END{
      miss_rate=(rows>0? miss/rows : 0.0);
      invalid_fields=invalid_chr+invalid_pos+invalid_gt;
      out_frac=(rows>0? out_of_order/rows : 0.0);

      # emit global stats line-by-line for bash to read safely
      printf "%d\n", rows;                 # 0
      printf "%d\n", bad;                  # 1
      printf "%d\n", invalid_chr;          # 2
      printf "%d\n", invalid_pos;          # 3
      printf "%d\n", invalid_gt;           # 4
      printf "%d\n", miss;                 # 5
      printf "%.6f\n", miss_rate;          # 6
      printf "%d\n", dup_rsid;             # 7
      printf "%d\n", non_rsid+0;           # 8
      printf "%d\n", out_of_order;         # 9
      printf "%.6f\n", out_frac;           # 10

      # per-chrom summary (compact single line: "chr:count:miss,chr:count:miss,...")
      first=1;
      for (i=1;i<=25;i++){
        if (chr_counts[i]>0 || chr_miss[i]>0){
          if (!first) printf ",";
          first=0;
          printf "%s:%d:%d", chr_label(i), chr_counts[i]+0, chr_miss[i]+0;
        }
      }
      printf "\n";                          # 11
    }'
)

rows="${stats[0]}"
bad="${stats[1]}"
invalid_chr="${stats[2]}"
invalid_pos="${stats[3]}"
invalid_gt="${stats[4]}"
miss="${stats[5]}"
miss_rate="${stats[6]}"
dup="${stats[7]}"
non_rsid="${stats[8]}"
out_of_order="${stats[9]}"
out_frac="${stats[10]}"
perchrom="${stats[11]}"

# Infer version by row count
infer_ver="unknown"
if (( rows >= EXPECT_V5_MIN && rows <= EXPECT_V5_MAX )); then infer_ver="v5"
elif (( rows >= EXPECT_V4_MIN && rows <= EXPECT_V4_MAX )); then infer_ver="v4"
elif (( rows >= EXPECT_V3_MIN && rows <= EXPECT_V3_MAX )); then infer_ver="v3"; fi

# PASS/WARN/FAIL logic
status="PASS"
notes=()

if (( bad > MAX_BAD_ROWS )); then status="FAIL"; notes+=("Too many malformed rows: $bad"); fi
if (( invalid_chr + invalid_pos + invalid_gt > MAX_INVALID_FIELDS )); then
  status="FAIL"
  ((invalid_chr>0)) && notes+=("Invalid chromosomes: $invalid_chr")
  ((invalid_pos>0)) && notes+=("Invalid positions: $invalid_pos")
  ((invalid_gt>0)) && notes+=("Invalid genotypes: $invalid_gt")
fi

rate_pct=$(awk -v x="$miss_rate" 'BEGIN{printf "%.2f", x*100}')
awk -v x="$miss_rate" -v thr="$MAX_MISS_RATE" 'BEGIN{exit !(x>thr)}' && { status="FAIL"; notes+=("Missing/no-call rate too high: '"$rate_pct"'%"); } || true

# Enforce expected 23andMe size windows unless explicitly relaxed
if [[ "$infer_ver" == "unknown" && "$FAIL_ON_UNKNOWN_VARIANT_COUNT" == "1" ]]; then
  status="FAIL"
  notes+=("Variant count ($rows) outside expected 23andMe v3/v4/v5 windows; file may be imputed, merged, or from a different vendor")
fi

# Warnings (do not flip PASS->FAIL)
if (( dup > WARN_DUP_RSIDS )); then notes+=("Many duplicate rsids: $dup"); [[ "$status" == "PASS" ]] && status="WARN"; fi
awk -v x="$out_frac" -v thr="$WARN_OUT_OF_ORDER_FRAC" 'BEGIN{exit !(x>thr)}' && { notes+=("Out-of-order rows (chr/pos): '"$out_of_order"' ('"$(awk -v x="$out_frac" 'BEGIN{printf "%.2f", x*100}')"'%)"); [[ "$status" == "PASS" ]] && status="WARN"; } || true

# Version window note (informational)
ver_note=""
if [[ "$infer_ver" == "unknown" ]]; then
  ver_note="Variant count ($rows) outside v3/v4/v5 windows."
fi

# Output path
OUTDIR="${PROJECT_ROOT}/users/${STEM}"
REPORT="${OUTDIR}/${STEM}_initial_qc.txt"
mkdir -p "$OUTDIR"

# Format per-chrom table for the report
perchrom_table=""
if [[ -n "$perchrom" ]]; then
  IFS=',' read -r -a pcs <<<"$perchrom"
  perchrom_table=$(
    printf "Per-chromosome counts (chr : variants, no-calls)\n"
    for kv in "${pcs[@]}"; do
      IFS=':' read -r c n m <<<"$kv"
      printf "  %-3s : %7d, %7d\n" "$c" "$n" "$m"
    done
  )
fi

{
  printf '====== 23andMe Raw File QC ======\n'
  printf 'Original file:  %s\n' "$INFILE"
  printf 'STEM:           %s\n' "$STEM"
  printf 'Detected cols:  %s\n' "${col_header:-'(not found; expected: rsid chromosome position genotype)'}"
  printf 'Generated at:   %s\n' "${gen_at:-'(unknown)'}"
  printf 'Genome build:   %s\n' "${gen_build:-'(unknown; usually GRCh37/hg19)'}"
  printf 'Declared ver:   %s\n' "${declared_ver:-'(none)'}"
  printf 'Inferred ver:   %s\n' "$infer_ver"
  printf '%s\n' '---------------------------------'
  printf 'Variants:       %s\n' "$rows"
  printf 'No-calls:       %s (%s%%)\n' "$miss" "$rate_pct"
  printf 'Malformed rows: %s\n' "$bad"
  printf 'Invalid chr:    %s\n' "$invalid_chr"
  printf 'Invalid pos:    %s\n' "$invalid_pos"
  printf 'Invalid GTs:    %s\n' "$invalid_gt"
  printf 'Duplicate rsids:%s\n' "$dup"
  printf 'Out-of-order:   %s (%.2f%%)\n' "$out_of_order" "$(awk -v x="$out_frac" 'BEGIN{printf "%.2f", x*100}')"
  printf 'Non-rsid IDs:   %s\n' "$non_rsid"
  printf '%s\n' '---------------------------------'
  printf 'Expected windows (variant count): v3 %s-%s | v4 %s-%s | v5 %s-%s\n' \
    "$EXPECT_V3_MIN" "$EXPECT_V3_MAX" "$EXPECT_V4_MIN" "$EXPECT_V4_MAX" "$EXPECT_V5_MIN" "$EXPECT_V5_MAX"
  if [[ -n "$ver_note" ]]; then printf 'Version note:   %s\n' "$ver_note"; fi
  printf '%s\n' '---------------------------------'
  printf '%s\n' "$perchrom_table"
  printf '%s\n' '---------------------------------'
  if ((${#notes[@]})); then
    printf 'Flags:\n'
    for n in "${notes[@]}"; do printf '  - %s\n' "$n"; done
  else
    printf 'Flags:          (none)\n'
  fi
  printf 'QC STATUS:      %s\n' "$status"
  printf '=================================\n'
} > "$REPORT"

# Exit code: fail only on FAIL
[[ "$status" == "FAIL" ]] && exit 1 || exit 0

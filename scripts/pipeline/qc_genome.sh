#!/usr/bin/env bash
set -euo pipefail

# 23andMe raw file QC + metadata extractor (silent)
# Usage: qc_23andme.sh path/to/23andme_raw.txt[.gz]
# Output: PROJECT_ROOT/users/STEM/STEM_initial_qc.txt

EXPECT_V5_MIN="${EXPECT_V5_MIN:-550000}"
EXPECT_V5_MAX="${EXPECT_V5_MAX:-700000}"
EXPECT_V4_MIN="${EXPECT_V4_MIN:-500000}"
EXPECT_V4_MAX="${EXPECT_V4_MAX:-650000}"
EXPECT_V3_MIN="${EXPECT_V3_MIN:-800000}"
EXPECT_V3_MAX="${EXPECT_V3_MAX:-1100000}"
MAX_BAD_ROWS="${MAX_BAD_ROWS:-0}"
MAX_MISS_RATE="${MAX_MISS_RATE:-0.02}"
PROJECT_ROOT="${PROJECT_ROOT:-$(pwd)}"

# Require exactly one arg; fail silently if not met
[[ $# -eq 1 ]] || exit 1

# Normalize input: strip trailing slash, require an existing file
INFILE="${1%/}"
[[ -f "$INFILE" ]] || exit 1

# STEM = basename without .gz and .txt
_base="$(basename "$INFILE")"
_base_no_gz="${_base%.gz}"
STEM="${_base_no_gz%.txt}"

# Ensure plain text for QC
if [[ "$INFILE" =~ \.gz$ ]]; then
  OUTTXT="${INFILE%.gz}.txt"
  gunzip -c "$INFILE" > "$OUTTXT"
  FILE="$OUTTXT"
else
  FILE="$INFILE"
fi

READER="cat"

# Header metadata
HEADER="$($READER "$FILE" | sed -n '1,200p' | grep '^#' || true)"
gen_at="$(grep -i '^#.*generated by 23andMe at:' <<<"$HEADER" | sed -E 's/^# *This data file generated by 23andMe at: *//I' | xargs || true)"
gen_build="$(grep -Ei '^#.*(genome assembly|build|GRCh|hg)[0-9]+' <<<"$HEADER" | sed -E 's/^# *//;s/\r$//' | head -n1 || true)"
col_header="$(grep -E '^# *rsid' <<<"$HEADER" | sed -E 's/^# *//' | head -n1 || true)"

stream() { $READER "$FILE" | tr -d '\r'; }

# Count data rows
total_variants="$(stream | awk 'BEGIN{c=0} !/^#/ && NF>0 {c++} END{print c}')"

# Validate & stats
readarray -t stats < <(
  stream | awk '
    BEGIN{
      FS="\t"; bad=0; invalid_chr=0; invalid_pos=0; invalid_rsid=0; invalid_gt=0;
      miss=0; rows=0; dup=0; out_of_order=0;
    }
    function c2n(c) {
      if (c ~ /^[0-9]+$/) return c+0;
      if (c=="X") return 23;
      if (c=="Y") return 24;
      if (c=="MT" || c=="M") return 25;
      return -1;
    }
    function valid_gt(g){ return (g ~ /^(AA|AC|AG|AT|CC|CG|CT|GG|GT|TT|--)$/) }
    !/^#/ && NF>0 {
      rows++;
      if (NF!=4) { bad++; next; }
      rs=$1; chr=$2; pos=$3; gt=$4;
      if (rs !~ /^rs[0-9]+$/) invalid_rsid++;
      chrnum=c2n(chr);
      if (chrnum<0 || chrnum>25) invalid_chr++;
      if (pos !~ /^[0-9]+$/ || pos==0) invalid_pos++;
      if (!valid_gt(gt)) invalid_gt++;
      if (gt=="--") miss++;
      if (seen[rs]++) dup++;
      if (rows==1){ prevc=chrnum; prevp=pos+0; }
      else {
        if (chrnum<prevc || (chrnum==prevc && (pos+0)<prevp)) out_of_order++;
        prevc=chrnum; prevp=pos+0;
      }
    }
    END{
      miss_rate=(rows>0)?miss/rows:0;
      print rows;
      print bad;
      print invalid_chr;
      print invalid_pos;
      print invalid_rsid;
      print invalid_gt;
      print miss;
      printf "%.6f\n", miss_rate;
      print dup;
      print out_of_order;
    }'
)

rows="${stats[0]}"
bad="${stats[1]}"
invalid_chr="${stats[2]}"
invalid_pos="${stats[3]}"
invalid_rsid="${stats[4]}"
invalid_gt="${stats[5]}"
miss="${stats[6]}"
miss_rate="${stats[7]}"
dup="${stats[8]}"
out_of_order="${stats[9]}"

declared_ver="$(grep -Eio 'v[0-9]+' <<<"$HEADER" | head -n1 || true)"
infer_ver="unknown"
if (( rows >= EXPECT_V5_MIN && rows <= EXPECT_V5_MAX )); then infer_ver="v5"
elif (( rows >= EXPECT_V4_MIN && rows <= EXPECT_V4_MAX )); then infer_ver="v4"
elif (( rows >= EXPECT_V3_MIN && rows <= EXPECT_V3_MAX )); then infer_ver="v3"
fi

status="OK"
notes=()
if (( bad > MAX_BAD_ROWS )); then status="FAIL"; notes+=("Too many malformed rows: $bad")
elif (( bad > 0 )); then notes+=("Has malformed rows: $bad"); fi
rate_pct="$(awk -v x="$miss_rate" 'BEGIN{printf "%.2f", x*100}')"
awk -v x="$miss_rate" -v thr="$MAX_MISS_RATE" 'BEGIN{exit !(x>thr)}' && { status="FAIL"; notes+=("Missing/no-call rate too high: ${rate_pct}%"); } || true
if (( invalid_chr>0 )); then status="FAIL"; notes+=("Invalid chromosomes: $invalid_chr"); fi
if (( invalid_pos>0 )); then status="FAIL"; notes+=("Invalid positions: $invalid_pos"); fi
if (( invalid_rsid>0 )); then notes+=("Non-rsid identifiers: $invalid_rsid"); fi
if (( invalid_gt>0 )); then status="FAIL"; notes+=("Invalid genotypes: $invalid_gt"); fi
if (( dup>0 )); then notes+=("Duplicate rsids: $dup"); fi
if (( out_of_order>0 )); then notes+=("Out-of-order rows (chr/pos): $out_of_order"); fi

ver_window_note=""
if [[ "$infer_ver" == "v5" ]]; then
  if (( rows < EXPECT_V5_MIN || rows > EXPECT_V5_MAX )); then
    status="WARN"
    ver_window_note="Variant count ($rows) outside v5 window [$EXPECT_V5_MIN,$EXPECT_V5_MAX]"
  fi
fi

# Output path
OUTDIR="${PROJECT_ROOT}/users/${STEM}"
REPORT="${OUTDIR}/${STEM}_initial_qc.txt"
mkdir -p "$OUTDIR"

{
  printf '====== 23andMe Raw File QC ======\n'
  printf 'Original file:  %s\n' "$INFILE"
  printf 'QC file (.txt): %s\n' "$FILE"
  printf 'STEM:           %s\n' "$STEM"
  printf 'Size:           %s\n' "$(du -h "$FILE" | awk '{print $1}')"
  printf 'Detected cols:  %s\n' "${col_header:-'(not found; expected: rsid chromosome position genotype)'}"
  printf 'Generated at:   %s\n' "${gen_at:-'(unknown)'}"
  printf 'Genome build:   %s\n' "${gen_build:-'(unknown; usually GRCh37/hg19)'}"
  printf 'Declared ver:   %s\n' "${declared_ver:-'(none in header)'}"
  printf 'Inferred ver:   %s\n' "$infer_ver"
  printf '---------------------------------\n'
  printf 'Variants:       %s\n' "$rows"
  printf 'No-calls:       %s (%s%%)\n' "$miss" "$rate_pct"
  printf 'Malformed rows: %s\n' "$bad"
  printf 'Invalid chr:    %s\n' "$invalid_chr"
  printf 'Invalid pos:    %s\n' "$invalid_pos"
  printf 'Non-rsid IDs:   %s\n' "$invalid_rsid"
  printf 'Invalid GTs:    %s\n' "$invalid_gt"
  printf 'Duplicate rsids:%s\n' "$dup"
  printf 'Out-of-order:   %s\n' "$out_of_order"
  printf '---------------------------------\n'
  printf 'Expected windows (by variant count):\n'
  printf '  v3: %s-%s\n' "$EXPECT_V3_MIN" "$EXPECT_V3_MAX"
  printf '  v4: %s-%s\n' "$EXPECT_V4_MIN" "$EXPECT_V4_MAX"
  printf '  v5: %s-%s\n' "$EXPECT_V5_MIN" "$EXPECT_V5_MAX"
  printf '---------------------------------\n'
  if [[ -n "$ver_window_note" ]]; then
    printf 'Version note:   %s\n' "$ver_window_note"
  fi
  if ((${#notes[@]})); then
    printf 'Flags:\n'
    for n in "${notes[@]}"; do printf '  - %s\n' "$n"; done
  else
    printf 'Flags:          (none)\n'
  fi
  printf 'QC STATUS:      %s\n' "$status"
  printf '=================================\n'
} > "$REPORT"
